% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cut_closure.R
\name{closure_cut}
\alias{closure_cut}
\title{Interval Closure Classification}
\usage{
closure_cut(x, breaks, label_vec = NULL, dig_lab = 3L,
  ordered_result = FALSE, env = parent.frame())
}
\arguments{
\item{x}{A numeric or integer vector to be categorized. Factors are
coerced to integers.}

\item{breaks}{Closure is determined by 'i' and 'e' for include and exclude,
respectively. If an interval has breaks c(i, i), the start of the next
interval is going to be (e, ?) since any other choice would create a hole
at that point in the range. If breaks are not named, the function defaults
to base::cut. Breaks that leave gaps will result in NA values. If you name
breaks with 'i' and 'e', do so consistently or you will be redirected to
base::cut with a warning.}

\item{label_vec}{The labels for the breaks. Order and length of labels must be
consistent with breaks. Default null causes labels to be based on break
intervals.}

\item{dig_lab}{the desired number of digits after the decimal point
(format = "f") or significant digits (format = "g", = "e" or = "fg").
Default: 2 for integer, 4 for real numbers. If less than 0, the C default of
6 digits is used. If specified as more than 50, 50 will be used with a
warning unless format = "f" where it is limited to typically 324.
(Not more than 15-21 digits need be accurate, depending on the OS and
compiler used. This limit is just a precaution against segfaults in the
underlying C runtime.)}

\item{ordered_result}{single logical value; should result be order?
default FALSE.}

\item{env}{the environment of base::cut, if that is triggered.
Default parent.frame().}
}
\value{
a factored vector; x is classified based on user inputs.
}
\description{
interval categorization capable of handling each interval's
boundary closures independently. This is designed to be used when base::cut
does not fully meet your needs, and is a wrapper for cut when breaks are
not named (see breaks). Unlike cut, gaps are permissible in consecutive
intervals, but will generate NAs.
}
\note{
Very large and very small numbers (less than 1e-12, greater than
1e16) may not work, use at your own risk, or, transform your data with a
shift parameter to a safe input range.
}
\examples{
\dontrun{ # maybe this will work later, not now
chol_guide <- data.table(
  init = c(0, 200, 240),
  end = c(200, 240, Inf),
  cat = c("best", "borderline", "poor"))
}
closure_cut(x = 200, breaks = c(i=0, ei = 200, ie = 240, e = Inf),
ordered_result = TRUE, label_vec = Cs(best, borderline, poor))
closure_cut(x = 200, breaks = c(i=0, ei = 200, ie = 240, e = Inf),
            ordered_result = FALSE,
            label_vec = Cs(best, borderline, poor))
closure_cut(x = 200, breaks = c(i=0, ei = 200, ie = 240, e = Inf),
            ordered_result = FALSE,
                        label_vec = NULL)
closure_cut(x = 200, breaks = c(i=0, ei = 200, ie = 240, e = Inf),
            ordered_result = FALSE, label_vec = NULL,)
d <- data.table(
  chol = sample(150:400, size = 1e3, replace = TRUE))
breaks  <-  c(i = 0, e = 200, i = 240, e = Inf)
d[, cat := closure_cut(chol, breaks)]
d

# gaps will generate NA values, consistent with cut
closure_cut(1, breaks = c(10, 20)) # base::cut applied
closure_cut(x=1, breaks = c(i = 10, i = 20))

\dontrun{
# BAD - will error
# error: too many labels
closure_cut(1, breaks = c(i=0, i=0, i = 1), label_vec = c("zero", "one", "two"))
two errors: break 4 misnamed, break 5 not named
closure_cut(x = 1, breaks = c(i=1,e = 2, i = 3, eerie = 4, 5))
}

### create an intentional gap ####'
\dontrun{
# BAD - if repeat x input (i.e. chol), will break
d[, chol, by = .(closure_cut(chol, breaks))]
#' # BAD - this wil give wrong answers... dont force a gap!
closure_cut(10, breaks = c(e=1, e=10-1e-10, i=10+1e-10, e=20),
   allow_gap = TRUE)
# GOOD - if you really want a gap, fix it like this:
test_gap <- closure_cut(c(1, 10, 15, 20),
 breaks = c(i=1, e=10-1e-10, i=10+1e-10, e=20),
 label_vec = c("a", "gap", "b"), allow_gap = TRUE)
print(test_gap)
test_gap[test_gap == "gap"] <- NA
print(test_gap)
}

\dontshow{
x = 200
breaks = c(i=0, ei = 200, ie = 240, e = Inf)
dig_lab = 3L
ordered_result = FALSE
env = parent.frame()
closure_cut(x, breaks, label_vec = NULL, dig_lab, ordered_result, env)
}

}

