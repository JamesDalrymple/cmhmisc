% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsubstring.R
\name{tsubstring}
\alias{tsubstring}
\alias{substrings}
\alias{tsubstrings}
\alias{tsubstr}
\alias{tsubstring}
\alias{tsub}
\title{tsubstring and transpose the resulting list efficiently}
\usage{
substrings(text, cuts = -1L, widths = FALSE, recycle = FALSE,
  extra = FALSE)

tsubstrings(x, cuts, widths = FALSE, recycle = FALSE, extra = FALSE,
  fill = NA, type.convert = FALSE, give.names = NULL)

tsubstr(x, start, stop, fill = NA, type.convert = FALSE,
  give.names = FALSE)

tsubstring(text, first, last = 1000000L, fill = NA, type.convert = FALSE,
  give.names = FALSE)

tsub(X, FUN, ..., fill = NA, type.convert = FALSE, give.names = FALSE)
}
\arguments{
\item{text}{A character vector.}

\item{cuts}{The vector of indices, or string widths which will be used to cut
the character vector into sub-strings. By default, \code{cuts = -1}. Any
negative integer will cause this function to return an unaltered
string.}

\item{widths}{Default is \code{FALSE}. This argument alteres the
interpretiation of the \code{cuts} vector as widths instead of indices.}

\item{recycle}{FALSE by default, when TRUE, the \code{cuts} sequence -- or
widths -- is repeated until the end of the string.}

\item{extra}{FALSE by default, when TRUE, any extra characters not contained
in the initial \code{cuts} sequence will be appended onto the end of the
returned list.}

\item{x}{The vector to split (and transpose), usually a column wrapped in a
data.table.}

\item{fill}{Default is \code{NA}. It is used to fill shorter list elements so
as to return each element of the transposed result of equal lengths.}

\item{type.convert}{\code{TRUE} calls \code{\link{type.convert}} with
\code{as.is=TRUE} on the columns.}

\item{give.names}{This setting is relevent when \code{tsubstrings} is not
being used within data.table, and is by default NULL. Column names can be
passed into this arguement, as well as TRUE, which will set names with V#,
and FALSE, which will force no names to be generated. Additionally, if the
arguement \code{cuts} is named, the \code{cuts} names will be used if
\code{give.names} is neglected. Like \code{tstrsplit}, \code{give.names} is
FALSE by default for \code{tsubstr}.}

\item{start}{An integer of the first element to be subsetted.}

\item{stop}{An integer of the last element to be subsetted.}

\item{first}{An integer of the first element to be subsetted.}

\item{last}{An integer of the last element to be subsetted.}

\item{X}{a vector (atomic or list) or an \code{\link{expression}}
    object.  Other objects (including classed objects) will be coerced
    by \code{base::\link{as.list}}.}

\item{FUN}{the function to be applied to each element of \code{X}:
    see \sQuote{Details}.  In the case of functions like
    \code{+}, \code{\%*\%}, the function name must be backquoted or quoted.}

\item{...}{optional arguments to \code{FUN}.}
}
\value{
An index split vector of sub-strings.

A transposed list after splitting by the indices provided.

A transposed list after subsetting by \code{start} and \code{stop}.

A transposed list after subsetting by \code{first} and \code{last}.

A transposed list after subsetting by the FUN function and it's
  arguements.
}
\description{
\code{substrings} & \code{tsubstring} work in similar fashion to
  \code{strsplit} & \code{tstrsplit}. They are used to split strings, or
  vectors of strings at a specified point. \code{tsubstring} was also
  designed for optimized use in data.table's, however, its function is to
  split string columns at a specific indices or widths, instead of using
  regular expressions.

\code{substrings} is a feature extended version of
  \code{substring} that allows for a varity of handling behaviors by way of
  argument selection.

\code{tsubstr} is the basic version of \code{tsubstrings} which
  only calls \code{substr} to do it's subsetting.

\code{tsubstring} is the basic version of \code{tsubstrings}
  which only calls \code{substring} to do it's subsetting. It is slightly
  faster than tsubstrings, yet has less functionality.

\code{tsubs} does the analogously the same thing as the other
  transpose wrapper functions, above, however, it allows the user to insert
  the  string handling function of your choice.
}
\details{
It internally calls \code{substrings} first, and then
  \code{\link{transpose}} on the result. \code{give.names} argument can be
  used to return an auto named list, although this argument does not have any
  effect when used with \code{:=}, which requires names to be provided
  explicitly. It might be useful in other scenarios.

It internally calls \code{substr} first, and then
  \code{\link{transpose}} on the result.

It internally calls \code{substring} first, and then
  \code{\link{transpose}} on the result.

It internally calls whatever function is loaded into the \code{FUN}
  arguement, and than calls \code{\link{transpose}} on the result. A this
  functions core, a call to \code{transpose(lapply(X, FUN, ...))} is being
  evalutated. This is very simular to just calling \code{apply(X, 1, FUN)} in
  order to apply a function on a row by row basis. I suspect using apply is
  more efficent in general.
}
\section{TODO}{

\itemize{
   \item{Add '.' to tsub like setf}
}


Adding the "." pacement function like setf
}

\examples{
txt <- "ABCDEFGJIJKLMN"
cuts <- c(1, 2, 4)
substrings(txt, cuts, widths = FALSE, recycle = FALSE, extra = FALSE)
substrings(txt, cuts, widths = TRUE , recycle = FALSE, extra = FALSE)
substrings(txt, cuts, widths = FALSE, recycle = TRUE , extra = FALSE)
substrings(txt, cuts, widths = TRUE , recycle = TRUE , extra = FALSE)
substrings(txt, cuts, widths = FALSE, recycle = TRUE , extra = TRUE )
substrings(txt, cuts, widths = TRUE , recycle = TRUE , extra = TRUE )
substrings(txt, cuts, widths = FALSE, recycle = FALSE, extra = TRUE )
substrings(txt, cuts, widths = TRUE , recycle = FALSE, extra = TRUE )

cnames <- c("one", "third", "two")
cuts <- setNames(cuts, cnames)
widths = FALSE ; recycle = FALSE ; extra = TRUE ; fill = NA
give.names = NULL #cnames
x <- rep(txt, 3)
DT <- data.table(x = x)
DT[, tsubstrings(x, cuts, give.names = give.names, extra = extra,
                recycle = recycle, widths = widths)]
DT[, tsubstr(x, start = 3, stop = 4)]
DT[, tsubstring(text = x, first = c(1,3,5,7), last = c(2,4,6,8))]
DT[, apply(.SD, MARGIN = 1, FUN = substring,
           first = c(1,3,5,7), last = c(2,4,6,8)),
   .SDc = 'x']
DT[, tsub(X = x, FUN = substring, first = c(1,3,5,7), last = c(2,4,6,8))]
}
\seealso{
\code{\link{substring}}

\code{\link{tstrsplit}}, \code{\link{transpose}}

\code{\link{tstrsplit}}, \code{\link{transpose}}

\code{\link{tstrsplit}}, \code{\link{transpose}}

\code{\link{lapply}}, \code{\link{apply}}, \code{\link{transpose}}
}
